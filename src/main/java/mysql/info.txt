mysql处理千万级数据太高了性能低
mysql处理io慢
nosql在应对高并发比mysql好很多

nosql对比关系型数据库 超大规模数据存储性能好很多
基于内存 因为Redis是基于内存的操作，
高效数据结构
多路I/O复用模型
单线程模型 CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽

innodb一次加载16K

索引失效
    索引列参与了运算、函数
    模糊查询时（like语句），模糊匹配的占位符位于条件的首部。
    查询列对比也无法利用索引有序结构
    联合索引的最左匹配原则
    使用select*无法走覆盖索引  回表次数多了 也会导致失效
    字段类型不同，而导致索引失效 字符串类型的字段使用int查询 因为mysql无法进行数字到字符串的11映射(字符串‘1’ ‘ 1’  '1a'都能转换为字符串)，
    如果使用了or关键字，那么它前面和后面的字段都要加索引

从索引存不存数据来看：聚集索引 非聚集索引
从索引列类型来看：  主键索引 唯一索引 普通索引 联合索引 前缀索引
从数据结构看：有hash索引  b+树索引
覆盖索引：所查询的列已经被包含在索引中。不用走回表，这种情况称为覆盖索引
建立联合索引 减少回表查询



数据库四种隔离级别：
    读未提交
    读已提交
    可重复读
    串行化

缓存与数据库一致性
    旁路缓存
        先更新缓存 再更新数据库
        先更新数据库 再更新缓存
            加锁 分布式锁 拿到锁的才能更新数据。但无法并发写 写操作多了就会有性能问题
        为什么删除缓存 而不是更新缓存呢?
            缓存多费劲
            而且你更新了  如果长时间不用不就没意义了吗？

         先删除缓存 再更新数据
         先更新数据库 再删除缓存（发生概率低）
            (如果更新数据库成功 删除缓存失败了呢 这不就又不一致了？)
                删除缓存放到mq中 异步删除缓存
                还可以监听数据库log 数据库更新成功删除缓存。而且可以不侵入业务代码
        比较好的方案 更新数据库 通过mq或者监听blog的方式异步删除缓存
    读穿写穿
    写回

mq
    解耦
    异步
    流量控制
    提高可靠性

LevelDB 将 Redis 缓存和持久层合二为一，一次性帮你搞定缓存和持久层
rocksDB是基于leveldb开发的并且解决了部分levelDb的问题
适合于高频写入的同时，提供快速地查找，通过牺牲了部分读性能，用来大幅提高写性能。这个设计思想的依据是：
新的写入总是将数据插入到memtable，读取在查询SST文件前总是要查询memtable，因为memtable里面的数据总是更新的。
一旦一个memtable被写满，他会变成不可修改的，并被一个新的memtable替换。一个后台线程会把这个memtable的内容落盘到一个SST文件，然后这个memtable就可以被销毁了。并且在flush的过程中，会完成数据的压缩